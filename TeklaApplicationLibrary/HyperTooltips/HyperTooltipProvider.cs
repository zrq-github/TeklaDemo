namespace Tekla.UI.HyperToolTips
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.IO;
    using System.Text;
    using System.Windows.Forms;

    /// <summary>
    /// This class is similar to standard <seealso cref="ToolTip"/>, it provides support for attaching HyperToolTips to various UI elements
    /// (<see cref="ToolStripItem"/> and <see cref="Control"/> are supported at the moment).
    /// 
    /// Typically <see cref="HyperToolTipProvider"/> is populated by autogenerated designer code.
    /// You have to drop <see cref="HyperToolTipProvider"/> to <see cref="Form"/> or <see cref="UserControl"/> in VS designer and
    /// then fill HyperToolTipId property for each UI element you want to have a HyperToolTip.
    /// 
    /// <seealso cref="TipLoader"/> can be used also to populate <see cref="HyperToolTipProvider"/> with controls in form,
    /// but it is not recomended way to use <see cref="HyperToolTipProvider"/>.
    /// </summary>
    [ProvideProperty("HyperToolTipId", typeof(object))]
    [ToolboxItemFilter("System.Windows.Forms")]
    [ToolboxBitmap(typeof(HyperToolTipProvider), "SuperToolTip.jpg")]
    [Category("Components")]
    public partial class HyperToolTipProvider : Component, IExtenderProvider
    {
        #region Constants

        /// <summary>
        /// The big size suffix.
        /// </summary>
        private const string BigSizeSuffix = "_l";

        /// <summary>
        /// The ext value.
        /// </summary>
        private const string Ext = ".html";

        #endregion

        #region Fields

        /// <summary>
        /// The _context ids.
        /// </summary>
        private readonly Hashtable contextIds = new Hashtable();

        /// <summary>
        /// The _files in chm lock.
        /// </summary>
        private readonly object filesInChmLock = new object();

        /// <summary>
        /// The _hover tracker.
        /// </summary>
        private readonly HoverTracker hoverTracker = new HoverTracker(); // one tracker per provider instance

        /// <summary>
        /// The _last popup visible.
        /// </summary>
        private readonly Stopwatch lastPopupVisible = new Stopwatch();

        /// <summary>
        /// The _show timer.
        /// </summary>
        private readonly Timer showTimer = new Timer();

        /// <summary>
        /// The _active.
        /// </summary>
        private bool active = true;

        /// <summary>
        /// The _fading interval.
        /// </summary>
        private int fadingInterval = 250;

        /// <summary>
        /// The _files in chm.
        /// </summary>
        private Hashtable filesInChm;

        /// <summary>
        /// The _initial delay.
        /// </summary>
        private int initialDelay = 500;

        /// <summary>
        /// The _namespace.
        /// </summary>
        private string namespaceName = string.Empty;

        /// <summary>
        /// The _opacity.
        /// </summary>
        private double opacity = 0.95;

        /// <summary>
        /// The _popup size large.
        /// </summary>
        private Size popupSizeLarge = new Size(320, 205);

        /// <summary>
        /// The _popup size normal.
        /// </summary>
        private Size popupSizeNormal = new Size(300, 145);

        /// <summary>
        /// The _reshow delay.
        /// </summary>
        private int reshowDelay = 500 / 5;

        /// <summary>
        /// The _show always.
        /// </summary>
        private bool showAlways;

        /// <summary>
        /// The _use fading.
        /// </summary>
        private bool useFading = SystemInformation.IsMenuAnimationEnabled && SystemInformation.IsMenuFadeEnabled;

        #endregion

        #region Constructors and Destructors

        /// <summary>
        /// Initializes a new instance of the <see cref="HyperToolTipProvider"/> class. 
        /// Initializes a new instance of the <see cref="HyperToolTipProvider"/> without a specified container. 
        /// </summary>
        /// <remarks>
        /// The <see cref="HyperToolTipProvider"/> constructor associates the <see cref="HyperToolTipProvider"/> class with the container that is creating the instance of the control.
        /// </remarks>
        /// <example>
        /// The following code example creates an instance of the <see cref="HyperToolTipProvider"/> class and associates the instance with the 
        /// <seealso cref="Form"/>
        /// that the instance is created within.
        /// The code then initializes the delay properties AutoPopDelay, <see cref="InitialDelay"/>, and <see cref="ReshowDelay"/>.
        /// In addition the instance of the <see cref="HyperToolTipProvider"/> class sets the <see cref="ShowAlways"/> property to <b>true.</b> to enable <see cref="HyperToolTipProvider"/> text to be displayed regardless of whether the form is active.
        /// Finally, the example associates HyperToolTip with two controls on a form, a <see cref="Button"/> and a <see cref="CheckBox"/>.
        /// The code example requires that the method defined in the example is located within a 
        /// <seealso cref="Form"/>
        /// that contains a <see cref="Button"/> control named button1 and a <see cref="CheckBox"/> control named checkBox1,
        /// and that the method is called from the constructor of the 
        /// <seealso cref="Form"/>
        /// <code>
        /// // This example assumes that the Form_Load event handling method
        /// // is connected to the Load event of the form.
        /// private void Form1_Load(object sender, System.EventArgs e)
        /// {
        ///     // Create the ToolTip and associate with the Form container.
        ///     HyperToolTipProvider hyperToolTipProvider1 = new HyperToolTipProvider();
        /// 
        ///     // Set up the delays for the HyperToolTip.
        ///     hyperToolTipProvider1.InitialDelay = 1000;
        ///     // Force the ToolTip text to be displayed whether or not the form is active.
        ///     hyperToolTipProvider1.ShowAlways = true;
        /// 
        ///     // Set up the ToolTip text for the Button and Checkbox.
        ///     hyperToolTipProvider1.SetHyperToolTipCId(this.button1, "button.1");
        ///     hyperToolTipProvider1.SetHyperToolTipCId(this.checkBox1, "checkBox.1");
        /// }
        /// </code>
        /// </example>
        public HyperToolTipProvider()
        {
            this.hoverTracker.TrackingStopped += this.HoverTrackerTrackingStoped;

            this.showTimer.Interval = this.InitialDelay;
            this.showTimer.Tick += delegate(object s, EventArgs ev)
                {
                    this.showTimer.Stop();
                    this.ShowTip(this.showTimer.Tag);
                };
        }

        /// <summary>Initializes a new instance of the <see cref="HyperToolTipProvider"/> class with a specified container.</summary>
        /// <param name="container">An <seealso cref="IContainer"/>
        /// that represents the container of the <seealso cref="HyperToolTipProvider"/>
        /// </param>
        /// <remarks>The <seealso cref="HyperToolTipProvider"/>
        /// constructor enables you to associate a <seealso cref="HyperToolTipProvider"/>
        /// with any container.
        /// A <seealso cref="HyperToolTipProvider"/>
        /// releases its resources when its container closes or is finalized.</remarks>
        public HyperToolTipProvider(IContainer container)
            : this()
        {
            container.Add(this);
        }

        #endregion

        #region Delegates

        /// <summary>
        /// Represents the method that will handle the <see cref="TipPopup"/> events of a <see cref="HyperToolTipProvider"/>.
        /// </summary>
        public delegate void TipEventHandler(object sender, TipEventArgs e);

        #endregion

        #region Public Events

        /// <summary>
        /// Occurs before a HyperToolTip is displayed.
        /// This event can be used to prevent tooltip from being displayed or to change <see cref="HyperToolTipPopup"/> apperance and/or content.
        /// </summary>
        [Description(
            "Occurs after all information about the tip is gathered but just befor the tip window is actually shown.")]
        public event TipEventHandler TipPopup;

        #endregion

        #region Public Properties

        /// <summary>
        /// Controls whether hyper tooltips should be displayed or not.
        /// </summary>
        /// <value><b>true.</b> if the HyperTooltip is currently active; otherwise, <b>false.</b>. The default is <b>true.</b>.</value>
        /// <remarks>
        /// With the Active property, you can enable or disable the display of HyperTooltip text for all controls that have text specified by this particular <see cref="HyperToolTipProvider"/> component.
        /// Although more than one <see cref="HyperToolTipProvider"/> component can be created and assigned to a form, setting the <b>Active.</b> property to <b>false.</b> only affects the current <see cref="HyperToolTipProvider"/>.
        /// You can enable users to set the value of this property in a form that provides application options.
        /// These options, in turn, provide the user with the ability to enable or disable the display of HyperTooltips in your application.
        /// </remarks>
        [DefaultValue(true)]
        [Description("Determines if the HyperToolTipProvider is active. A Tip will appear only if the HyperToolTipProvider has been activated.")]
        public bool Active
        {
            get
            {
                return this.active;
            }

            set
            {
                this.active = value;

                // disable normal tooltips for ToolStrip
                foreach (var control in this.contextIds.Keys)
                {
                    if (control is ToolStripItem)
                    {
                        if (null != (control as ToolStripItem).Owner)
                        {
                            (control as ToolStripItem).Owner.ShowItemToolTips = !this.active;
                        }

                        // TODO: this way we forgot original value of ShowItemToolTips and can't restore it when Active==false
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets a value indicating debug execution mode.
        /// Debug mode to be used by documentation team to get information about TipContextIds associated with controls.
        /// When <b>true.</b> TipContextId value is placed to clipboard on mouse over the control and SHIFT pressed.
        /// </summary>
        /// <value>value indicating debug execution mode.</value>
        [DefaultValue(false)]
        [Description("Debug mode to be used by documentation team to get information about TipContextIds associated with controls.")]
        public bool Debug { get; set; }

        /// <summary>
        /// Get/set total fading time in milleseconds. The bigger number the slower fading is.
        /// <seealso cref="UseFading"/> should be set to <b>true.</b> to turn fading effect on.
        /// </summary>
        /// <value>Total time of fading interval in milleseconds.</value>
        [DefaultValue(250)]
        [Description("Total time of fading effect.")]
        public int FadingInterval
        {
            get
            {
                return this.fadingInterval;
            }

            set
            {
                if (value > 0)
                {
                    this.fadingInterval = value;
                }
                else
                {
                    throw new ArgumentException("Value must be greater than 0.");
                }
            }
        }

        /// <summary>
        /// Gets or sets the amount of time which passes, in milliseconds, before a tip is displayed.
        /// </summary>
        /// <value>The period of time, in milliseconds, that the pointer must remain stationary on a control before the ToolTip window is displayed.</value>
        /// <remarks>
        /// With the InitialDelay property, you can shorten or lengthen the time that the ToolTip waits before displaying a ToolTip window.
        /// If the value of the InitialDelay property is set to a value that is too long in duration,
        /// the user of your application might not know that your application provides ToolTip Help.
        /// You can use this property to ensure that the user has ToolTips displayed quickly by shortening the time specified.
        /// </remarks>
        [DefaultValue(500)]
        [Description("Determines the lenght of time the pointer must remain stationary within a ToolTip region before the HyperToolTip window appears.")]
        public int InitialDelay
        {
            get
            {
                return this.initialDelay;
            }

            set
            {
                this.initialDelay = value;
            }
        }

        /// <summary>
        /// Get/set opacity for tooltip window. If <see cref="UseFading"/> is <b>true.</b> this is a maximum opacity.
        /// </summary>
        /// <value>Opacity for tooltip window.</value>
        [DefaultValue(0.95)]
        public double Opacity
        {
            get
            {
                return this.opacity;
            }

            set
            {
                this.opacity = value;
            }
        }

        /// <summary>
        /// Get/set a large size for popup tooltip window. This size is used in case othervise is not specified.
        /// </summary>
        /// <value>Size of the popup window with HypetTooltip used in case '_l' suffix is added to html file name.</value>
        [DefaultValue(typeof(Size), "320, 205")]
        [Description(
            "Determines the large size for popup tooltip window (in case '_l' suffix is added to html file name).")]
        public Size PopupSizeLarge
        {
            get
            {
                return this.popupSizeLarge;
            }

            set
            {
                this.popupSizeLarge = value;
            }
        }

        /// <summary>
        /// Get/set a normal size for popup tooltip window. This size is used in case othervise is not specified.
        /// </summary>
        /// <value>Size of the popup window with HypetTooltip used in case othervise is not specified.</value>
        [DefaultValue(typeof(Size), "300, 145")]
        [Description("Determines the normal size for popup tooltip window.")]
        public Size PopupSizeNormal
        {
            get
            {
                return this.popupSizeNormal;
            }

            set
            {
                this.popupSizeNormal = value;
            }
        }

        /// <summary>
        /// Gets or sets the length of time that must transpire before subsequent ToolTip windows appear as the mouse pointer moves from one control to another.
        /// </summary>
        /// <value>The length of time (in milliseconds) that it takes subsequent ToolTip windows to appear.</value>
        /// <remarks>
        /// This property enables you to shorten or lengthen the time that the ToolTip waits before displaying a ToolTip window
        /// after a previous ToolTip window is displayed.
        /// The first time a ToolTip window is displayed the value of the <see cref="InitialDelay"/> property is used to determine the delay
        /// to apply before initially showing the ToolTip window. When a ToolTip window is currently being displayed
        /// and the user moves the cursor to another control that displays a ToolTip window,
        /// the value of the <see cref="ReshowDelay"/> property is used before showing the ToolTip for the new control.
        /// The ToolTip window from the previous control must still be displayed in order for the delay specified in the <see cref="ReshowDelay"/> property to be used;
        /// otherwise the InitialDelay property value is used.
        /// </remarks>
        [DefaultValue(500 / 5)]
        [Description(
            "Determines the length of time that must transpire before subsequent ToolTip windows appear as the mouse pointer moves from one control to another."
            )]
        public int ReshowDelay
        {
            get
            {
                return this.reshowDelay;
            }

            set
            {
                this.reshowDelay = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether a HyperToolTip window is displayed, even when its parent control is not active.
        /// </summary>
        /// <value><b>true.</b> if the HyperToolTip is always displayed; otherwise, <b>false.</b>. The default is <b>false.</b>.</value>
        [DefaultValue(false)]
        [Description("Determines if the HyperToolTip will be displayed always, even if the parent window is not active.")]
        public bool ShowAlways
        {
            get
            {
                return this.showAlways;
            }

            set
            {
                this.showAlways = value;
            }
        }

        /// <summary>
        /// Gets or sets a value specifying the name of the Help file to get tips' content from.
        /// </summary>
        /// <value>The name of the Help file. This can be of the form C:\path\tooltips.chm or /folder/sample.chm.</value>
        /// <remarks>
        /// The file name retrieved by this method identifies the file that provides HyperTooltip support for all the controls for which this object provides Tips.
        /// This file name can designate a compiled Help (.chm).
        /// <seealso cref="GetTipInfo"/> use this propety to build full url to the tip content.
        /// </remarks>
        [Localizable(true)]
        [Description("The Tips namespace (for example CHM file) that will be used.")]
        public virtual string TipsNamespace
        {
            get
            {
                return this.namespaceName;
            }

            set
            {
                if (this.namespaceName != value)
                {
                    this.filesInChm = null;
                }

                this.namespaceName = value ?? string.Empty;
            }
        }

        /// <summary>
        /// Get/set whether to use fadding while show tooltip window.
        /// <seealso cref="FadingInterval"/> is used to define the speed of fading.
        /// </summary>
        /// <value><b>true.</b> indicates fadding will be used.</value>
        [DefaultValue(true)]
        [Description("When set to true, a fade effect is used when HypetToolTips are shown or hidden.")]
        public bool UseFading
        {
            get
            {
                return this.useFading;
            }

            set
            {
                this.useFading = value;
            }
        }

        #endregion

        #region Public Methods and Operators

        /// <summary>Indicates whether this object can provide its extender properties to the specified object.
        /// This class can extend <see cref="ToolStripItem"/> and <see cref="Control"/>.</summary>
        /// <param name="target">The object to receive the extender properties.</param>
        /// <returns><b>true.</b> if this object can provide extender properties to the specified object; otherwise, <b>false.</b>.</returns>
        public virtual bool CanExtend(object target)
        {
            if ((target is Control && !(target is TabControl || target is Form || target is ToolStrip))
                || target is ToolStripItem)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>This is the extended property for the HyperTooltipId property.</summary>
        /// <param name="control">An item (<see cref="Control"/> or <see cref="ToolStripItem"/>) for which Tip will be displayed.</param>
        /// <returns>id of HyperToolTip for the control to find content, 
        /// <code>
        /// string.Empty.</code>
        /// if <paramref name="control"/> is not registered.</returns>
        /// <exception cref="ArgumentNullException">if control is <b>null.</b>.</exception>
        /// <exception cref="ArgumentException">if control's type is not supported.</exception>
        [Localizable(true)]
        [DisplayName("HyperTooltipId")]
        [Category("Behavior")]
        [Description("id used to find HyperToolTip's content")]
        [DefaultValue("")]
        public virtual string GetHyperToolTipId(object control)
        {
            if (control == null)
            {
                throw new ArgumentNullException("control");
            }

            if (!this.CanExtend(control))
            {
                throw new ArgumentException("This type of controls is not supported", "control");
            }

            string id;
            lock (this.contextIds)
            {
                id = (string)this.contextIds[control];
            }

            return id ?? string.Empty;
        }

        /// <summary>This is the extended property for the HyperTooltipId property.
        /// Note that for <seealso cref="TabPage"/>
        /// it is important to call this method after tab is added to <seealso cref="TabControl"/>
        /// </summary>
        /// <param name="control">An <see cref="ToolStripItem"/> or <see cref="Control"/> for which Tip will be displayed.</param>
        /// <param name="value">id of HyperToolTip for the control to find content. If 
        /// <code>
        /// null.</code>
        /// or 
        /// <code>
        /// string.Empty.</code>
        /// hyperTooltipId is removed.</param>
        /// <exception cref="ArgumentNullException">if control is 
        /// <code>
        /// null.</code>
        /// </exception>
        /// <exception cref="ArgumentException">if control's type is not supported.</exception>
        public virtual void SetHyperToolTipId(object control, string value)
        {
            if (control == null)
            {
                throw new ArgumentNullException("control");
            }

            if (!this.CanExtend(control))
            {
                throw new ArgumentException("This type of control is not supported", "control");
            }

            lock (this.contextIds)
            {
                if (this.contextIds.ContainsKey(control))
                {
                    if (string.IsNullOrEmpty(value))
                    {
                        this.contextIds.Remove(control);

                        // deattach handlers
                        if (control is Control)
                        {
                            if (control is TabPage)
                            {
                                // TabPage is a special case: unhook events for parent TabControl only if it was the last TabPage with HyperToolTip
                                var page = control as TabPage;
                                if (null != page.Parent)
                                {
                                    foreach (TabPage p in (page.Parent as TabControl).TabPages)
                                    {
                                        if (this.contextIds.ContainsKey(p))
                                        {
                                            return;
                                        }
                                    }

                                    this.Deattach(page.Parent);
                                }
                            }
                            else
                            {
                                this.Deattach(control as Control);
                            }
                        }
                        else if (control is ToolStripItem)
                        {
                            this.Deattach(control as ToolStripItem);
                        }
                        else
                        {
                            System.Diagnostics.Debug.Assert(false, "Unsupported control");
                        }

                        return;
                    }

                    this.contextIds[control] = value;
                }
                else
                {
                    this.contextIds.Add(control, value);

                    // hook events to our event handlers
                    if (control is Control)
                    {
                        if (control is TabPage)
                        {
                            // TabPage is a special case: we have to hook events for parent TabControl
                            // Also make sure to register only once for each TabControl even if several pages has a HyperToolTips
                            var page = control as TabPage;
                            if (null == page.Parent)
                            {
                                // delayed attaching to parent when it will be available
                                page.ParentChanged += delegate(object sender, EventArgs e)
                                    {
                                        var tabCtrl = page.Parent as TabControl;
                                        this.Attach(tabCtrl);
                                    };
                            }
                            else
                            {
                                this.Attach(page.Parent);
                            }
                        }
                        else
                        {
                            this.Attach(control as Control);
                        }

                        // make sure control is removed from our collection on disposing
                        (control as Control).Disposed += delegate(object sender, EventArgs e) { this.SetHyperToolTipId(control, null); };
                    }
                    else if (control is ToolStripItem)
                    {
                        this.Attach(control as ToolStripItem);
                        if (this.Active)
                        {
                            // disable normal tooltips for ToolStrip
                            if (null != (control as ToolStripItem).Owner)
                            {
                                (control as ToolStripItem).Owner.ShowItemToolTips = false;
                            }

                            // TODO: this way we forgot original value of ShowItemToolTips and can't restore it when Active==false
                        }

                        // make sure control is removed from our collection on disposing
                        (control as ToolStripItem).Disposed +=
                            delegate(object sender, EventArgs e) { this.SetHyperToolTipId(control, null); };
                    }
                    else
                    {
                        System.Diagnostics.Debug.Assert(false, "Unsupported control");
                    }
                }
            }
        }

        #endregion

        #region Methods

        /// <summary>Clean up any resources being used.</summary>
        /// <param name="disposing">True if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.hoverTracker.Dispose();
                this.contextIds.Clear();
                if (null != this.filesInChm)
                {
                    this.filesInChm.Clear();
                    this.filesInChm = null;
                }
            }

            base.Dispose(disposing);
        }

        /// <summary>Maps <seealso cref="SetHyperToolTipId"/>
        /// to filenames inside CHM file.
        /// It is required because file name can have additional suffixes that used e.g. to specify tip window size.</summary>
        /// <param name="id">HyperTooltipId (<seealso cref="SetHyperToolTipId"/>
        /// ) for the UI element.</param>
        /// <returns>filename inside CHM that corresponds to id passed, 
        /// <code>
        /// null.</code>
        /// if file for this id wasn't found.</returns>
        protected virtual string GetFileName(string id)
        {
            id = id.Replace('\\', '/');
            if (!id.StartsWith("/"))
            {
                id = "/" + id;
            }

            lock (this.filesInChmLock)
            {
                if (null == this.filesInChm)
                {
                    this.BuildFileNamesCache();
                }

                return (string)this.filesInChm[id];
            }
        }

        /// <summary>Builds Tip's content url using values set with <seealso cref="TipsNamespace"/>
        /// and <seealso cref="SetHyperToolTipId"/>
        /// If <seealso cref="TipsNamespace"/>
        /// specifies relative path then <see cref="AppDomain.BaseDirectory"/> is user to combine a full path.
        /// Can be overwritten to define another url scheme to find tips' content.
        /// Also extract other tip attibutes that can be specified by documentor in tip's content file.</summary>
        /// <param name="control">An item (<see cref="Control"/> or <see cref="ToolStripItem"/>) for which Tip will be displayed.</param>
        /// <returns><seealso cref="TipInfo"/>
        /// filled with information about the hypertooltip if it is defined and to be shown, <b>null.</b> othewize (if hypertooltip is not defined for this control).</returns>
        protected virtual TipInfo GetTipInfo(object control)
        {
            var info = new TipInfo { Id = (string)this.contextIds[control] };

            if (string.IsNullOrEmpty(info.Id))
            {
                return null;
            }

            var path = this.TipsNamespace.Replace('/', Path.DirectorySeparatorChar);
            if (!Path.IsPathRooted(path))
            {
                path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path);
            }

            var filename = this.GetFileName(info.Id);
            if (null == filename)
            {
                info.Url = "ms-its:" + path + "::" + info.Id + Ext;
                info.ContentExists = false;
            }
            else
            {
                info.Url = "ms-its:" + path + "::" + filename;
                info.ContentExists = true;
                info.Size = filename.EndsWith(BigSizeSuffix + Ext) ? this.PopupSizeLarge : this.PopupSizeNormal;
            }

            return info;
        }

        /// <summary>Raises the <see cref="TipPopup"/> event.</summary>
        /// <param name="e">The data for the event.</param>
        protected virtual void OnTipPopup(TipEventArgs e)
        {
            if (this.TipPopup != null)
            {
                this.TipPopup(this, e);
            }
        }

        /// <summary>The attach.</summary>
        /// <param name="ctrl">The ctrl.</param>
        private void Attach(ToolStripItem ctrl)
        {
            System.Diagnostics.Debug.Assert(ctrl != null);

            this.Deattach(ctrl);
            ctrl.MouseEnter += this.OnMouseEntered;
            ctrl.MouseLeave += this.OnMouseLeave;
            ctrl.MouseDown += this.OnMouseDown;
        }

        /// <summary>The attach.</summary>
        /// <param name="ctrl">The ctrl.</param>
        private void Attach(Control ctrl)
        {
            System.Diagnostics.Debug.Assert(ctrl != null);

            // check whether we are subscribed already, if yes then no need to subscribe twice
            // if (ctrl.MouseEnter != null)
            // {
            // foreach (Delegate d in ctrl.MouseEnter.GetInvocationList())
            // {
            // if (d == OnMouseEntered)
            // return;
            // }
            // }
            // if (ctrl.MouseLeave != null)
            // {
            // foreach (Delegate d in ctrl.MouseLeave.GetInvocationList())
            // {
            // if (d == OnMouseLeave)
            // return;
            // }
            // }
            this.Deattach(ctrl);
            ctrl.MouseEnter += this.OnMouseEntered;
            ctrl.MouseLeave += this.OnMouseLeave;
            ctrl.MouseDown += this.OnMouseDown;
        }

        /// <summary>
        /// The build file names cache.
        /// </summary>
        private void BuildFileNamesCache()
        {
            lock (this.filesInChmLock)
            {
                this.filesInChm = new Hashtable();

                var path = this.TipsNamespace.Replace('/', Path.DirectorySeparatorChar);
                if (!Path.IsPathRooted(path))
                {
                    path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, path);
                }

                if (!File.Exists(path))
                {
                    return;
                }

                using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    using (var br = new BinaryReader(fs))
                    {
                        var bytes = new byte[(int)fs.Length];
                        br.Read(bytes, 0, bytes.Length);

                        var startIndex = 1; // what is the header size in CHM we could skip?
                        var encoding = Encoding.ASCII;
                        var byteDot = encoding.GetBytes(new[] { '.' });
                        while ((startIndex = Array.IndexOf(bytes, byteDot[0], startIndex)) != -1)
                        {
                            if (encoding.GetString(bytes, startIndex, Ext.Length) == Ext)
                            {
                                var inxd = startIndex;

                                // while (Array.IndexOf(Path.GetInvalidPathChars(), encoding.GetChars(bytes, inxd - 1, 1)[0]) == -1 || encoding.GetChars(bytes, inxd - 1, 1)[0] == '%')
                                while (bytes[inxd - 1] > 0x27 || encoding.GetChars(bytes, inxd - 1, 1)[0] == ' ')
                                {
                                    inxd--;
                                }

                                var cnt = startIndex - inxd + Ext.Length;
                                var filename = encoding.GetString(bytes, inxd, cnt);
                                if (filename.IndexOf('/') >= 0)
                                {
                                    // looks like a file name
                                    // filename should start with '/', so trim any gerbage from begining
                                    filename = filename.Remove(0, filename.IndexOf('/'));

                                    // calculate HyperTooltipId from filename
                                    var id = filename.Substring(0, filename.Length - Ext.Length);
                                    if (id.EndsWith(BigSizeSuffix))
                                    {
                                        id = id.Substring(0, id.Length - BigSizeSuffix.Length);
                                    }

                                    if (!this.filesInChm.ContainsKey(id))
                                    {
                                        this.filesInChm.Add(id, filename);
                                    }
                                }
                            }

                            startIndex++;
                        }
                    }
                }
            }
        }

        /// <summary>The deattach.</summary>
        /// <param name="ctrl">The ctrl.</param>
        private void Deattach(ToolStripItem ctrl)
        {
            System.Diagnostics.Debug.Assert(ctrl != null);
            ctrl.MouseEnter -= this.OnMouseEntered;
            ctrl.MouseLeave -= this.OnMouseLeave;
            ctrl.MouseDown -= this.OnMouseDown;
        }

        /// <summary>The deattach.</summary>
        /// <param name="ctrl">The ctrl.</param>
        private void Deattach(Control ctrl)
        {
            System.Diagnostics.Debug.Assert(ctrl != null);
            ctrl.MouseEnter -= this.OnMouseEntered;
            ctrl.MouseLeave -= this.OnMouseLeave;
            ctrl.MouseDown -= this.OnMouseDown;
        }

        /// <summary>The hover tracker_ tracking stoped.</summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The e value.</param>
        private void HoverTrackerTrackingStoped(object sender, HoverTracker.TrackerEventArgs e)
        {
            // System.Console.WriteLine("HoverTracker_TrackingStoped...");
            if (null != e.Popup)
            {
                e.Popup.Dispose();
            }

            // hack for TabPage to show a tip window for other tab when user move the mouse over control header
            // It is needed because TabControl send MouseHover event only once on entering headers area,
            // it doesn't send events for each tab
            if (e.Control is TabPage)
            {
                var mousePos = Cursor.Position;
                var tabCtrl = (e.Control as TabPage).Parent as TabControl;
                if (null != tabCtrl)
                {
                    // TabPage parent could be null in case controls are disposed already
                    for (var i = 0; i < tabCtrl.TabCount; i++)
                    {
                        var rect = tabCtrl.RectangleToScreen(tabCtrl.GetTabRect(i));
                        if (rect.Contains(mousePos))
                        {
                            // emulate event to show tip for other tab page
                            this.OnMouseEntered(tabCtrl.TabPages[i], null);
                        }
                    }
                }
            }

            this.lastPopupVisible.Reset();
            this.lastPopupVisible.Start(); // track time popup was last visible in order to implement ReshowDelay;
        }

        /// <summary>The on mouse down.</summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The e value.</param>
        private void OnMouseDown(object sender, EventArgs e)
        {
            // System.Console.WriteLine("OnMouseDown...");

            // stop current timer if any
            this.showTimer.Enabled = false;
            if (this.hoverTracker.Tracking)
            {
                this.hoverTracker.Stop();
            }
        }

        /// <summary>The on mouse entered.</summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The e value.</param>
        private void OnMouseEntered(object sender, EventArgs e)
        {
            if (!this.Active)
            {
                return;
            }

            // System.Console.WriteLine("OnMouseEntered...");

            // stop current timer if any
            this.showTimer.Enabled = false;

            // check whether popup for this control is displayed already
            // it happens in a situation when popup is shown, use moves mouse from control to popup content and then back so MouseEntered is fired again
            if (this.hoverTracker.Tracking && this.hoverTracker.Control == sender)
            {
                return;
            }

            if (this.InitialDelay == 0)
            {
                this.ShowTip(sender);
            }
            else
            {
                // schedule one tick timer to delay show tooltip
                if (this.hoverTracker.Tracking
                    || (this.lastPopupVisible.IsRunning && this.lastPopupVisible.ElapsedMilliseconds <= this.ReshowDelay))
                {
                    this.showTimer.Interval = this.ReshowDelay;
                }
                else
                {
                    this.showTimer.Interval = this.InitialDelay;
                }

                this.showTimer.Tag = sender;
                this.showTimer.Start();
            }
        }

        // this handler is responsible on stopping pending popup from showing when mouse cursor leaves the control area

        /// <summary>The on mouse leave.</summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The e value.</param>
        private void OnMouseLeave(object sender, EventArgs e)
        {
            // System.Console.WriteLine("OnMouseLeave...");

            // stop current timer if any
            this.showTimer.Enabled = false;
        }

        // this handler is responsible on stopping pending popup from showing when user clicks mouse
        // if popup currently shown it should be closed

        /// <summary>This methos called when it is actually time to show the popup tip window.
        /// The method should determine whether hypertooltip should be shown (is defined) or not.
        /// It is responsible for attaching all nesesary handlers to track mouse etc. to hide tip window on a right time.</summary>
        /// <param name="sender">The sender.</param>
        private void ShowTip(object sender)
        {
            // System.Console.WriteLine("ShowTip...");
            var mousePos = Cursor.Position;

            // special handling for tab pages:
            // tipId property is defined for TabPage but Mouse events are sent by parent TabControl for tabs headers.
            // So we have to find a page inside TabControl this event is related to.
            if (sender is TabControl)
            {
                var tabCtrl = sender as TabControl;
                for (var i = 0; i < tabCtrl.TabCount; i++)
                {
                    var rect = tabCtrl.GetTabRect(i);
                    rect = tabCtrl.RectangleToScreen(rect);
                    if (rect.Contains(mousePos))
                    {
                        sender = tabCtrl.TabPages[i];
                        break;
                    }
                }

                System.Diagnostics.Debug.Assert(
                    sender is TabPage, "handler installed but page is not found for TabControl");
            }

            var parent = sender as Control;
            if (sender is ToolStripItem && (sender as ToolStripItem).Owner is ToolStrip)
            {
                parent = (sender as ToolStripItem).Owner as ToolStrip;
            }

            var info = this.GetTipInfo(sender);
            if (null != info)
            {
                // place url to clipboard in debug mode
                if (this.Debug && (Control.ModifierKeys == Keys.Shift))
                {
                    Clipboard.SetText(info.Id /*info.url*/);
                }

                // Check if tip is defined but content doesn't exist. Don't try to open window at all in this case.
                if (!info.ContentExists)
                {
                    if (this.Debug)
                    {
                        var msg = string.Format("Resource doesn't exist: {0}", info.Url);

                        // show tooltip window with url to missing resource
                        var wnd = new ToolTipPopup(msg);

                        // fire event and give a chance for client to alter tip window properties or even cancel the tip
                        var args = new TipEventArgs(wnd, sender);
                        this.OnTipPopup(args);
                        if (args.Cancel)
                        {
                            return;
                        }

                        wnd.Show(parent);
                        this.hoverTracker.Start(sender, wnd);
                    }
                    else
                    {
                        if (sender is ToolStripItem)
                        {
                            var item = sender as ToolStripItem;
                            if (!string.IsNullOrEmpty(item.ToolTipText))
                            {
                                // fallback to normal tooltip
                                var wnd = new ToolTipPopup(item.ToolTipText);
                                wnd.Show(parent);
                                this.hoverTracker.Start(sender, wnd);
                            }
                        }
                    }
                }
                else
                {
                    // there was strange behaviour sometimes when single shared instance of HyperToolTipPopup was used
                    // so create a new instance each time.
                    // set all parameters for tip window to give a chance to alter them in event handler
                    var wnd = new HyperToolTipPopup { UseFading = this.UseFading, FadingInterval = this.FadingInterval, Opacity = this.Opacity, Size = info.Size, TipUrl = info.Url };


                    // fire event and give a chance for client to alter tip window properties or even cancel the tip
                    var args = new TipEventArgs(wnd, sender);
                    this.OnTipPopup(args);
                    if (args.Cancel)
                    {
                        return;
                    }

                    wnd.Show(parent);

                    // start tracking, we will receive TrackingStopped event when tracking will be stopped
                    this.hoverTracker.Start(sender, wnd);
                }
            }
            else
            {
                // show normal tooltips as a fallback for toolbar items
                if (sender is ToolStripItem)
                {
                    var item = sender as ToolStripItem;
                    if (!string.IsNullOrEmpty(item.ToolTipText))
                    {
                        // fallback to normal tooltip
                        var wnd = new ToolTipPopup(item.ToolTipText);
                        wnd.Show(parent);
                        this.hoverTracker.Start(sender, wnd);
                    }
                }
            }
        }

        #endregion

        /// <summary>
        /// Provides data for the <see cref="TipPopup"/> event. 
        /// </summary>
        public class TipEventArgs : EventArgs
        {
            #region Fields

            /// <summary>
            /// The _instance.
            /// </summary>
            private readonly object instance;

            /// <summary>
            /// The _wnd value.
            /// </summary>
            private readonly Popup wnd;

            #endregion

            #region Constructors and Destructors

            /// <summary>Initializes a new instance of the <see cref="TipEventArgs"/> class. 
            /// Creates a new instance of a <see cref="TipEventArgs"/> object.</summary>
            /// <param name="wnd">The <see cref="HyperToolTipPopup"/> to be shown.</param>
            /// <param name="instance">The object for which the HyperToolTip was displayed.</param>
            public TipEventArgs(Popup wnd, object instance)
            {
                this.wnd = wnd;
                this.instance = instance;
            }

            #endregion

            #region Public Properties

            /// <summary>
            /// Gets or sets whether the tip is prevented from being displayed.
            /// </summary>
            /// <value><b>True.</b> if the tip should not be displayed; otherwise, <b>false.</b>, and the tip is displayed.</value>
            /// <remarks>This property is only used with the <see cref="TipPopup"/> event.</remarks>
            public bool Cancel { get; set; }

            /// <summary>
            /// Gets the object for which the tip is displayed.
            /// </summary>
            /// <value>The Object for which the tip is displayed. For example, on a toolbar control, this would be an instance of a toolbar button object.</value>
            public object Instance
            {
                get
                {
                    return this.instance;
                }
            }

            /// <summary>
            /// Gets the <see cref="HyperToolTipPopup"/> to be shown.
            /// </summary>
            /// <value>The <see cref="HyperToolTipPopup"/> to be shown.</value>
            /// <remarks>You can modify properties of the window to alter the tip before it is shown.</remarks>
            public Popup Window
            {
                get
                {
                    return this.wnd;
                }
            }

            #endregion
        }

        /// <summary>
        /// Information about the tip required to show popup.
        /// If <see cref="ContentExists"/> is <b>false.</b> then all other properties except <see cref="Id"/> are undefined.
        /// </summary>
        protected class TipInfo
        {
            #region Constructor

            /// <summary>Initializes a new instance of the <see cref="TipInfo"/> class.</summary>
            protected internal TipInfo()
            {
                this.ContentExists = false;
                this.Id = string.Empty;
                this.Size = new Size();
                this.Url = string.Empty;
            }

            #endregion
            #region Fields

            /// <summary>Gets or sets a value indicating whether the hypertooltip is found inresources.</summary>
            /// <value>The content exists.</value>
            public bool ContentExists { get; set; }

            /// <summary>Gets or sets the HyperTooltipId defined via <seealso cref="SetHyperToolTipId"/>.</summary>
            /// <value>The id value.</value>
            public string Id { get; set; }

            /// <summary>Gets or sets the <seealso cref="Size"/> of the tip window to show.</summary>
            /// <value>The size value.</value>
            public Size Size { get; set; }

            /// <summary>Gets or sets the url to content of the tip to display, <b>null.</b> if tip is not to be shown.</summary>
            /// <value>The url value.</value>
            public string Url { get; set; }

            #endregion
        }
    }
}